<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WinGo Market Prediction</title>
<style>
  /* Reset & basics */
  body, html {
    margin:0; padding:0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    display: flex; flex-direction: column; min-height: 100vh;
  }
  h1 {
    margin: 1rem auto 0.5rem;
    font-weight: 700;
  }

  /* Container */
  .container {
    max-width: 480px;
    margin: auto;
    background: #222;
    border-radius: 12px;
    padding: 1rem 1.5rem 2rem;
    box-shadow: 0 0 20px rgba(255,255,255,0.05);
    position: relative;
    overflow: hidden;
  }

  /* Background animated spiderweb effect (canvas) */
  canvas#bgCanvas {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 0;
  }

  /* Timeframe buttons */
  .time-frames {
    display: flex; gap: 10px; justify-content: center; margin-bottom: 1rem;
  }
  .time-frame-btn {
    flex: 1;
    background: #333;
    border: none;
    padding: 0.5rem 0;
    border-radius: 8px;
    color: #eee;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.3s ease;
    user-select: none;
  }
  .time-frame-btn:hover:not(.active) {
    background: #444;
  }
  .time-frame-btn.active {
    background: #0a74da;
    box-shadow: 0 0 8px #0a74da;
  }

  /* Timer */
  .timer {
    text-align: center;
    font-size: 1.3rem;
    margin-bottom: 1rem;
  }
  .timer span {
    font-weight: 700;
    background: #0a74da;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    letter-spacing: 0.1rem;
  }

  /* Game history table */
  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1rem;
  }
  thead th {
    background: #0a74da;
    padding: 0.6rem 0.4rem;
    font-weight: 700;
  }
  tbody td {
    text-align: center;
    padding: 0.4rem 0;
    border-bottom: 1px solid #333;
    font-size: 0.9rem;
  }
  tbody tr:nth-child(even) {
    background: #1a1a1a;
  }
  .color-dot {
    display: inline-block;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    margin: 0 2px;
    vertical-align: middle;
  }
  .color-red { background: #e74c3c; }
  .color-green { background: #27ae60; }
  .color-violet { background: #9b59b6; }

  /* Prediction output */
  .prediction {
    background: #0a74da;
    border-radius: 8px;
    padding: 1rem;
    color: white;
    font-weight: 600;
    box-shadow: 0 0 12px #0a74da;
  }
  .prediction ul {
    padding-left: 1rem;
    margin-top: 0.5rem;
  }

  /* Responsive */
  @media (max-width: 520px) {
    .container {
      margin: 0 10px;
      padding: 1rem 1rem 2rem;
    }
  }
</style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<div class="container" role="main" aria-label="WinGo Market Prediction Tool">
  <h1>WinGo Market Prediction</h1>

  <nav class="time-frames" role="tablist" aria-label="Select timeframe">
    <button class="time-frame-btn active" data-tf="WinGo_30S" role="tab" aria-selected="true" tabindex="0">30 Sec</button>
    <button class="time-frame-btn" data-tf="WinGo_1M" role="tab" aria-selected="false" tabindex="-1">1 Min</button>
    <button class="time-frame-btn" data-tf="WinGo_3M" role="tab" aria-selected="false" tabindex="-1">3 Min</button>
    <button class="time-frame-btn" data-tf="WinGo_5M" role="tab" aria-selected="false" tabindex="-1">5 Min</button>
  </nav>

  <div class="timer" aria-live="polite" aria-atomic="true">
    Time Remaining: <span id="time-remaining">--:--</span>
  </div>

  <table aria-label="Game history table" role="grid">
    <thead>
      <tr>
        <th scope="col">Period</th>
        <th scope="col">Number</th>
        <th scope="col">Big/Small</th>
        <th scope="col">Color</th>
      </tr>
    </thead>
    <tbody id="game-history">
      <tr><td colspan="4" style="color:#777;">Loading...</td></tr>
    </tbody>
  </table>

  <section class="prediction" aria-live="polite" aria-atomic="true" id="prediction-output">
    Loading prediction...
  </section>
</div>

<script>
(() => {
  const API_BASE = "https://draw.ar-lottery01.com/WinGo";
  const defaultTf = "WinGo_30S";
  let currentTf = defaultTf;
  let timerInterval = null;

  const buttons = document.querySelectorAll(".time-frame-btn");
  const historyTable = document.getElementById("game-history");
  const predictionOutput = document.getElementById("prediction-output");
  const timeRemainingEl = document.getElementById("time-remaining");

  buttons.forEach(btn => {
    btn.addEventListener("click", () => {
      if (btn.classList.contains("active")) return;
      // Update active button styles & ARIA
      buttons.forEach(b => {
        b.classList.remove("active");
        b.setAttribute("aria-selected", "false");
        b.tabIndex = -1;
      });
      btn.classList.add("active");
      btn.setAttribute("aria-selected", "true");
      btn.tabIndex = 0;

      currentTf = btn.dataset.tf;
      resetTimer();
      loadDataAndPredict();
    });
  });

  // Fetch and render data + prediction
  async function loadDataAndPredict() {
    predictionOutput.textContent = "Loading prediction...";
    historyTable.innerHTML = '<tr><td colspan="4" style="color:#777;">Loading...</td></tr>';

    try {
      // Fetch history
      const url = `${API_BASE}/${currentTf}/GetHistoryIssuePage.json?pageNo=1`;
      const res = await fetch(url);
      const json = await res.json();
      if (json.code !== 0) throw new Error("API returned error");

      const draws = json.data.list;

      // Render table
      historyTable.innerHTML = draws.map(d => {
        // Color dots
        const colors = d.color.split(",");
        const colorDots = colors.map(c => `<span class="color-dot color-${c}"></span>`).join("");

        return `<tr>
          <td>${d.issueNumber}</td>
          <td style="color:${colors.includes("red") ? "#e74c3c" : colors.includes("green") ? "#27ae60" : "#9b59b6"}; font-weight:700;">${d.number}</td>
          <td>${d.number >= 5 ? "Big" : "Small"}</td>
          <td>${colorDots}</td>
        </tr>`;
      }).join("");

      // Update countdown from server timestamp â€” fallback to 60 sec countdown for demo
      startTimer(60);

      // Prediction
      const prediction = predict(draws);
      predictionOutput.innerHTML = `
        Predicted Size: <strong>${prediction.size}</strong> (Confidence: ${prediction.sizeConfidence})<br />
        Predicted Color: <strong>${prediction.color.charAt(0).toUpperCase() + prediction.color.slice(1)}</strong> (Confidence: ${prediction.colorConfidence})<br />
        Weighted Avg Number: <strong>${prediction.weightedAvg}</strong><br />
        Likely Numbers:
        <ul>
          ${prediction.topNums.map(n => `<li>#${n.number} (${(n.probability * 100).toFixed(1)}%)</li>`).join('')}
        </ul>
      `;

    } catch (e) {
      console.error(e);
      historyTable.innerHTML = '<tr><td colspan="4" style="color:#e74c3c;">Failed to load data.</td></tr>';
      predictionOutput.textContent = "Error loading prediction.";
    }
  }

  // Prediction engine
  function predict(draws) {
    const freq = Array(10).fill(0);
    let w = 1;
    for (let d of draws) {
      freq[parseInt(d.number)] += w;
      w *= 0.75;
    }

    let totalWeight = 0;
    let weightedSum = 0;
    w = 1;
    for (let d of draws) {
      const num = parseInt(d.number);
      weightedSum += num * w;
      totalWeight += w;
      w *= 0.75;
    }
    const weightedAvg = weightedSum / totalWeight;

    let bigScore = 0;
    let smallScore = 0;
    w = 1;
    for (let d of draws) {
      const num = parseInt(d.number);
      if (num >= 5) bigScore += w;
      else smallScore += w;
      w *= 0.75;
    }
    const size = bigScore > smallScore ? 'Big' : 'Small';
    const sizeConfidence = Math.abs(bigScore - smallScore) / (bigScore + smallScore);

    const colorCount = { red: 0, green: 0, violet: 0 };
    w = 1;
    for (let d of draws) {
      d.color.split(',').forEach(c => {
        if (colorCount[c] !== undefined) colorCount[c] += w;
      });
      w *= 0.75;
    }
    const sortedColors = Object.entries(colorCount).sort((a,b) => b[1] - a[1]);
    const color = sortedColors[0][0];
    const colorConfidence = sortedColors[0][1] / (sortedColors[0][1] + sortedColors[1][1] + sortedColors[2][1]);

    const topNums = freq
      .map((val, i) => ({ num: i, freq: val }))
      .sort((a,b) => b.freq - a.freq)
      .slice(0, 5)
      .map(x => ({ number: x.num, probability: (x.freq / freq.reduce((a,b)=>a+b,0)).toFixed(2) }));

    return { 
      size, 
      sizeConfidence: (sizeConfidence * 100).toFixed(1) + '%',
      color, 
      colorConfidence: (colorConfidence * 100).toFixed(1) + '%',
      weightedAvg: weightedAvg.toFixed(2),
      topNums 
    };
  }

  // Timer (simple countdown for demo)
  let countdown = 60;
  function startTimer(seconds) {
    clearInterval(timerInterval);
    countdown = seconds;
    updateTimerDisplay();
    timerInterval = setInterval(() => {
      countdown--;
      if (countdown <= 0) {
        clearInterval(timerInterval);
        loadDataAndPredict();
      }
      updateTimerDisplay();
    }, 1000);
  }

  function updateTimerDisplay() {
    const mins = Math.floor(countdown / 60);
    const secs = countdown % 60;
    timeRemainingEl.textContent = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
  }

  function resetTimer() {
    clearInterval(timerInterval);
    timeRemainingEl.textContent = '--:--';
  }

  // Background spiderweb effect canvas - subtle, desktop/mobile friendly
  const canvas = document.getElementById('bgCanvas');
  const ctx = canvas.getContext('2d');
  let width, height;
  let points = [];

  function initCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    points = [];
    const gridX = 15;
    const gridY = 10;

    for(let x=0; x<=gridX; x++) {
      for(let y=0; y<=gridY; y++) {
        points.push({
          x: (width / gridX) * x + (Math.random()*20-10),
          y: (height / gridY) * y + (Math.random()*20-10),
          originX: (width / gridX) * x,
          originY: (height / gridY) * y,
          vx: 0,
          vy: 0
        });
      }
    }
  }

  function animateCanvas() {
    ctx.clearRect(0,0,width,height);
    // Move points slightly
    points.forEach(p => {
      p.vx += (Math.random() - 0.5) * 0.1;
      p.vy += (Math.random() - 0.5) * 0.1;
      p.x += p.vx;
      p.y += p.vy;
      // Bounce back to origin softly
      p.vx += (p.originX - p.x) * 0.01;
      p.vy += (p.originY - p.y) * 0.01;
    });

    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;

    // Draw lines between close points
    for(let i=0; i<points.length; i++) {
      for(let j=i+1; j<points.length; j++) {
        const dx = points[i].x - points[j].x;
        const dy = points[i].y - points[j].y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 120) {
          ctx.globalAlpha = 1 - dist/120;
          ctx.beginPath();
          ctx.moveTo(points[i].x, points[i].y);
          ctx.lineTo(points[j].x, points[j].y);
          ctx.stroke();
        }
      }
    }
    ctx.globalAlpha = 1;

    // Draw points
    points.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fill();
    });

    requestAnimationFrame(animateCanvas);
  }

  window.addEventListener('resize', () => {
    initCanvas();
  });

  // Init and run
  initCanvas();
  animateCanvas();
  loadDataAndPredict();

})();
</script>
</body>
</html>
